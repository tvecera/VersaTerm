// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// ------- //
// uart_tx //
// ------- //

#define uart_tx_wrap_target 0
#define uart_tx_wrap 4

static const uint16_t uart_tx_program_instructions[] = {
		//     .wrap_target
		0x9fa0, //  0: pull   block           side 1 [7]
		0x20a0, //  1: wait   1 pin, 0
		0xf727, //  2: set    x, 7            side 0 [7]
		0x6001, //  3: out    pins, 1
		0x0643, //  4: jmp    x--, 3                 [6]
		//     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program uart_tx_program = {
		.instructions = uart_tx_program_instructions,
		.length = 5,
		.origin = -1,
};

static inline pio_sm_config uart_tx_program_get_default_config(uint offset) {
	pio_sm_config c = pio_get_default_sm_config();
	sm_config_set_wrap(&c, offset + uart_tx_wrap_target, offset + uart_tx_wrap);
	sm_config_set_sideset(&c, 2, true, false);
	return c;
}

#include "hardware/clocks.h"
// UART TX initialization function
static inline void uart_tx_program_init(PIO pio, uint sm, uint offset, uint pin_tx, uint lcd_cs_pin, uint baud) {
	// Tell PIO to initially drive output-high on the selected pin, then map PIO
	// onto that pin with the IO muxes.
	pio_sm_set_pins_with_mask(pio, sm, 1u << pin_tx, 1u << pin_tx);
	// Set TX pin as output
	pio_sm_set_pindirs_with_mask(pio, sm, 1u << pin_tx, 1u << pin_tx);
	pio_gpio_init(pio, pin_tx);
	// Initialize the LCD CS pin as input
	pio_sm_set_consecutive_pindirs(pio, sm, lcd_cs_pin, 1, false);      // Set LCD CS pin as input
	pio_gpio_init(pio, lcd_cs_pin);
	// Get default config and modify
	pio_sm_config c = uart_tx_program_get_default_config(offset);
	// OUT shifts to right, no autopull
	sm_config_set_out_shift(&c, true, false, 32);
	// We are mapping both OUT and side-set to the same pin, because sometimes
	// we need to assert user data onto the pin (with OUT) and sometimes
	// assert constant values (start/stop bit)
	sm_config_set_out_pins(&c, pin_tx, 1);
	sm_config_set_sideset_pins(&c, pin_tx);
	// Set IN base pin to lcd_cs_pin for reading its state
	sm_config_set_in_pins(&c, lcd_cs_pin);
	// We only need TX, so get an 8-deep FIFO!
	sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);
	// SM transmits 1 bit per 8 execution cycles.
	float div = (float)clock_get_hz(clk_sys) / (8 * baud);
	sm_config_set_clkdiv(&c, div);
	// Initialize and enable the state machine
	pio_sm_init(pio, sm, offset, &c);
	pio_sm_set_enabled(pio, sm, true);
}
static inline void uart_tx_program_set_baudrate(PIO pio, uint sm, uint baud) {
	// The state machine processes 1 bit per 8 execution cycles.
	float div = (float)clock_get_hz(clk_sys) / (8 * baud);
	pio_sm_set_clkdiv(pio, sm, div);
}
static inline void uart_tx_program_putc(PIO pio, uint sm, char c) {
	pio_sm_put_blocking(pio, sm, (uint32_t)c);
}
static inline void uart_tx_program_puts(PIO pio, uint sm, const char *s) {
	while (*s)
		uart_tx_program_putc(pio, sm, *s++);
}

#endif

// ------- //
// uart_rx //
// ------- //

#define uart_rx_wrap_target 0
#define uart_rx_wrap 9

static const uint16_t uart_rx_program_instructions[] = {
		//     .wrap_target
		0x20a2, //  0: wait   1 pin, 2
		0x2020, //  1: wait   0 pin, 0
		0xea27, //  2: set    x, 7                   [10]
		0x4001, //  3: in     pins, 1
		0x0643, //  4: jmp    x--, 3                 [6]
		0x00c9, //  5: jmp    pin, 9
		0xc014, //  6: irq    nowait 4 rel
		0x20a0, //  7: wait   1 pin, 0
		0x0000, //  8: jmp    0
		0x8020, //  9: push   block
		//     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program uart_rx_program = {
		.instructions = uart_rx_program_instructions,
		.length = 10,
		.origin = -1,
};

static inline pio_sm_config uart_rx_program_get_default_config(uint offset) {
	pio_sm_config c = pio_get_default_sm_config();
	sm_config_set_wrap(&c, offset + uart_rx_wrap_target, offset + uart_rx_wrap);
	return c;
}

// UART RX initialization function
static inline void uart_rx_program_init(PIO pio, uint sm, uint offset, uint pin_rx, uint lcd_cs_pin, uint baud) {
	// Initialize the RX pin (UART receive pin)
	pio_sm_set_consecutive_pindirs(pio, sm, pin_rx, 1, false);
	pio_gpio_init(pio, pin_rx);
	gpio_pull_up(pin_rx);
	pio_sm_config c = uart_rx_program_get_default_config(offset);
	// Initialize the LCD CS pin as input
	pio_sm_set_consecutive_pindirs(pio, sm, lcd_cs_pin, 1, false);  // Set LCD CS pin as input
	pio_gpio_init(pio, lcd_cs_pin);
	// Set the IN base pin to pin_rx (UART RX pin)
	sm_config_set_in_pins(&c, pin_rx);  // For WAIT, IN instructions
	// Set the JMP pin to the UART RX pin
	sm_config_set_jmp_pin(&c, pin_rx);  // For JMP instructions
	// Shift to right, autopush disabled
	sm_config_set_in_shift(&c, true, false, 32);
	// Deeper FIFO as we're not doing any TX
	sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
	// SM transmits 1 bit per 8 execution cycles.
	float div = (float)clock_get_hz(clk_sys) / (8 * baud);
	sm_config_set_clkdiv(&c, div);
	// Initialize and enable the state machine
	pio_sm_init(pio, sm, offset, &c);
	pio_sm_set_enabled(pio, sm, true);
}
static inline void uart_rx_program_set_baudrate(PIO pio, uint sm, uint baudrate) {
	// The state machine processes 1 bit per 8 execution cycles.
	float div = (float)clock_get_hz(clk_sys) / (8 * baudrate);
	pio_sm_set_clkdiv(pio, sm, div);
}
static inline unsigned char uart_rx_program_getc(PIO pio, uint sm, unsigned char *c) {
	// 8-bit read from the uppermost byte of the FIFO, as data is left-justified
	io_rw_8 *rxfifo_shift = (io_rw_8*)&pio->rxf[sm] + 3;
	if (pio_sm_is_rx_fifo_empty(pio, sm)) {
		return 0;
	}
	*c = (char)*rxfifo_shift;
	return 1;
}

#endif
